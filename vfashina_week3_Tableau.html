<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>vfashina_week3_tableau</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="vfashina_week3_Tableau_files/libs/clipboard/clipboard.min.js"></script>
<script src="vfashina_week3_Tableau_files/libs/quarto-html/quarto.js"></script>
<script src="vfashina_week3_Tableau_files/libs/quarto-html/popper.min.js"></script>
<script src="vfashina_week3_Tableau_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="vfashina_week3_Tableau_files/libs/quarto-html/anchor.min.js"></script>
<link href="vfashina_week3_Tableau_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="vfashina_week3_Tableau_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="vfashina_week3_Tableau_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="vfashina_week3_Tableau_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="vfashina_week3_Tableau_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<h2 class="anchored">
<strong>Week 3</strong>
</h2>

<details>
<summary>
<strong>Saturday</strong>
</summary>
<h2 class="anchored">
Visualization Of National Centers For Environmental Information (NCEI) Dataset
</h2>
<p><strong>The context of the dataset</strong></p>
<p>The dataset is a collection of meteorological observations from a specific weather station identified as “KJELLER AIRPORT, NO”. This dataset is used by the National Center For Environmental Information (NCEI) for studying weather trends, creating predictive models, or understanding how atmospheric conditions change over time.</p>
<p>Based on the column names and data structure, the dataset consists of:</p>
<p><strong>1. Geographical Information:</strong> - <strong>STATION, LATITUDE, LONGITUDE, ELEVATION:</strong> These columns provide details about the specific location where the weather observations were recorded.</p>
<p><strong>2. Time-based Observations:</strong> - <strong>Date/Time:</strong> The dataset records weather data at hourly intervals, providing a time-series structure for analyzing weather patterns.</p>
<p><strong>3. Meteorological Data:</strong> - <strong>SLP (Sea Level Pressure):</strong> Atmospheric pressure at sea level, which is useful in studying weather systems, such as predicting storm conditions or high-pressure systems. - <strong>WND, TMP, VIS, DEW, etc.:</strong> These columns seem to encode data on wind speed/direction, temperature, visibility, dew point, and other weather-related variables. They are stored in a format that requires further decoding.</p>
<p><strong>4. Purpose:</strong> - It would appear that the is used for tracking and analyzing weather conditions over time at the specified station. It could be useful for forecasting, climate studies, or aviation-related weather monitoring.</p>
<p><strong>The source and link to the dataset - (csv)</strong></p>
<ul>
<li><p>The source is National Centre For Environment Information (NCEI)</p></li>
<li><p><a href="https://www.ncei.noaa.gov/data/global-hourly/access/2024/01466099999.csv" class="uri">https://www.ncei.noaa.gov/data/global-hourly/access/2024/01466099999.csv</a></p></li>
<li><p>Name : 2024-08-26 10:32 - 93K</p></li>
<li><p>Original dataset consists of 301 rows and 25 columns.</p></li>
<li><p>Cleaned dataset consists of 301 rows and 28 columns.</p></li>
<li><p>9 columns were deleted(correlation with other columns not clear and also not necessary for this analysis)</p></li>
<li><p>5 of the original columns were decoded into 11 additional columns:</p></li>
<li><p>Wind is decoded into</p></li>
<li><p>Wind_Direction</p></li>
<li><p>Wind_Speed_Tenths</p></li>
<li><p>Wind_Speed_Quality</p></li>
<li><p>Wind_Speed_Meters</p></li>
<li><p>Wind_Type</p></li>
<li><p>Temperature is decoded into</p></li>
<li><p>Temperature_Celsius</p></li>
<li><p>Temperature_Quality</p></li>
<li><p>Sea_Level_Pressure_hPa is decoded into</p></li>
<li><p>Sea_Level_Pressure_hPa</p></li>
<li><p>SLP_Quality</p></li>
<li><p>Dew is decoded into 2 columns</p></li>
<li><p>Dew_Point_Celsius</p></li>
<li><p>Dew_Point_Quality</p></li>
<li><p>Date was seperated to 2 columns</p></li>
<li><p>Date</p></li>
<li><p>Time</p></li>
</ul>
<section id="data-cleaning-methods-employed" class="level3">
<h3 class="anchored" data-anchor-id="data-cleaning-methods-employed"><strong>Data Cleaning Methods Employed</strong></h3>
<p>###<strong>Column Selection</strong></p>
<p>Out of the original 25 columns, 9 were found to be missing chunks of data. These 9 columns were dropped using Python and importing Pandas as pd. I then fed the NCEI dataset into Python using “data = pd.read_csv(r’C:\path_to_the_dataset_on_my PC. csv)”</p>
<p>I used python to print the data column heads - print(data.head()))</p>
<p>I had it print null data by “print(data.isnull().sum())</p>
<p>I also had python drop the null columns “data_cleaned = data.dropna())</p>
<pre><code>-   Total 9 columns were dropped.</code></pre>
<p><strong>Decoding Encoded Data:</strong> <strong>Date Conversion</strong></p>
<p><strong>Converted <code>DATE</code> Column to Datetime:</strong> The <code>DATE</code> column originally combined both dated and time. I split this into two separate columns by using the text to column function in excel.</p>
<p><strong>Sea Level Pressure (<code>SLP</code>) Conversion</strong> <strong>Reformatted and Converted <code>SLP</code>:</strong> The <code>SLP</code> column contained values in string format with commas as delimiters. I decoded this using the Excel’s text to column function. The same method was used to decode the Wind, Temperature, and Dew variables.</p>
<p><strong>Adding visualization to quarto document, including label and captions.</strong></p>
<p><strong>Visualizatin in Tableau.</strong> Throughout this third week, I worked extensively with Tableau, finding it to be a highly enjoyable and powerful visualization tool. While there is a lot to learn within a short time, Tableau’s detailed and visually appealing outputs make the effort worthwhile. Although Tableau incorporates some object-oriented programming concepts, it’s not something we needed to delve into deeply during this period.</p>
<p>This week, I created two notable visualizations using the NCEI dataset: a static wind rose and a radial wind rose. Tableau initially struggled with generating a traditional wind rose, so I opted to create a radial one instead (Both created programtically). The wind rose, intended to mimic the function of a windmill for weather observation, serves as a graphical tool to display the distribution of wind speed and direction over a specific period. It provides a concise visual summary of how wind speed and direction are typically distributed at a location, aiding in identifying prevailing wind patterns. The wind mill describes my dataset perfectly. Below is a copy of my dashboard using Tableau.</p>
<p><img src="Tableau_Dashboard.png" class="img-fluid"></p>
<p>Above Tableau dashboard displays various visualizations of the weather center data, offering insights into wind patterns and conditions:</p>
<ol type="1">
<li><p><strong>WNDIRSPEED</strong>: This plot aims to illustrate the wind speed over time, broken down by months. It shows how wind speed fluctuates throughout different months, with January showing a noticeable peak. This could indicate periods of higher wind activity during certain months.</p></li>
<li><p><strong>RadialWR (Radial Wind Rose)</strong>: The radial wind rose displays the distribution of wind direction and speed in a circular format, indicating the frequency and strength of winds coming from various directions. It helps in identifying the prevailing wind directions and their intensities.</p></li>
<li><p><strong>WndRose (Wind Rose)</strong>: This is a bar chart version of a wind rose, categorizing wind speed by direction groups (N, NE, E, etc.). It shows which directions have higher wind speeds on average, indicating that winds from the NE and S directions are particularly strong in this dataset. Additionally, i have included temperature data, i supect a potential correlation between wind direction and temperature changes.</p></li>
<li><p><strong>BarChart</strong>: This chart displays the average wind speed across different bins. It shows how often different wind speed ranges occur, highlighting that higher speeds (around 80) are less frequent but still present, indicating a varied wind speed distribution.</p></li>
</ol>
<p><strong>Overall Interpretation</strong>: - The visualizations suggest that wind speed and direction vary across time and direction, with some directions (NE, S) showing higher wind speeds. - There might be a relationship between wind direction and temperature, as seen in the Wind Rose plot. - The radial wind rose helps identify the most common wind directions and their speeds, which could be useful for understanding local weather patterns or for purposes like wind energy assessments.</p>
<p>These plots collectively provide a comprehensive view of the wind and temperature data, aiding in the analysis of prevailing wind conditions and their potential impact on the environment.</p>
</section>

</details></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>